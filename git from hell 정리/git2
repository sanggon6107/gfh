reset :
	약간 어려우므로 나중에 원리 익히고 다시 본다.

	reset vs revert : 비스한 듯 다르다. reset에도 여러 옵션이 있다.

git reset "commit id" --hard :
	commit id가 최신 커밋이 되도록 그 이후의 커밋 히스토리를 삭제한다.(깃은 웬만하면 아무것도 삭제하지 않기 때문에, 
	사실은 남아있다. 다만, 이것은 원리를 이해해야함)

git reset 주의사항 :
	원격 저장소에 공유를 하게 되면, 버전 정보를 인터넷에 공유하게 된다.
	그 이후에는 절대로 reset을 하면 안된다.
	reset은 원격 저장소에 공유하기 전 자신의 컴퓨터에서만 한다.

git revert :
	지금 이해하지 않아도 됨. 버전을 삭제 하면서 새로운 버전을 만드는 것임.

깃을 스스로 공부하는 방법 :
	가장 많이 나오는 것부터 익힌다. 어려운 것도 좋으나, 쉽지만 가장 근본적이고 많이 사용되는 것들을
	가장 잘 익혀야 한다.

	깃은 스스로 공부할 수 있다.
	git commit --help라고 쳐보자. 여러 가지 커밋 옵션이 나온다.

	예를 들어, git commit -a는 삭제, modify된 것들을 자동으로 스테이지 올려주고, 커밋을 한다는 뜻이다.
	m과 합성하여 git commit -am ""과 같이 쓸 수 있다.

	커뮤니티 사이트에도 적극적으로 질문하자.

gistory
	.git이 관리하는 파일의 목록은 INDEX에서 볼 수 있다.
	파일 목록을 보면 해시가 있는데, 오브젝트의 주소이다. 즉, 해당 파일 오브젝트가 'objecs/앞 두글자/나머지'에
	저장되어있다는 뜻.

	git에서는 똑같은 내용의 코드는 모두 똑같은 해시값으로 인코딩된다. 따라서, 모든 같은 코드는 같은 이름을
	갖는다.(효율적)

	commit을 하면 또 다른  object가 생성되는데, 거기에는 tree가 있다.
	그 tree를 들어가면 각 파일들의 오브젝트의 정보가 들어있다.
	parent를 보면 그 commit의 이전 커밋 내용을 볼 수 있다.

	따라서, 각각의 버전은 해당 정보의 스냅샷(마치 사진같은 그 순간의 상황)을 tree라는 곳에 저장해 둔다. 


	정리 : object는 크게 세 종류. blob(파일 내용), tree(스냅샷), commit(커밋 정보)

git 윈리 - status의 원리
	git status 를 치면 '커밋할 것이 없다'라고 뜬다. 어떤 원리일까?
	-> 현재 index의 내용과, 가장 최신 commit 오브젝트의 tree 내용이 같다면, 변경 사항 없는 것.
	실험. 파일을 수정하면, index에 써져 있는 것과 실제 파일이 다르다면, 그것은 modfied인 것.

	add를 하면 index 안에 있는 blob의 해시가 바뀐다. 그런데 최신 커밋의 트리에 있는 해당 파일의 blob 해시의
	는 그대로이다. 따라서 수정한 것이 있다는 것. 따라서 스테이지에 있는 것은 index에 반영되고, 그것을 commit의 트리에 있는
	blob들과 비교한다. 즉, 'stage area의 정보 = Index', '프로젝트 폴더 = working space'.

branch
	
	"새로운 branch를 만든다."
