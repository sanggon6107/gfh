git commit -a 설정 주의사항 :
	-a 설정은, 자동으로 스테이지에 올려주는 설정. 즉, 스테이지에 올라가지 않은
	파일도 자동으로 add해주고, 그 다음 commit한다.
	하지만 한번도 add 하지 않은 파일은 add 해주지 않는다.

branch :
	분기 만든다.

git branch :
	현재 사용하는 branch를 출력해준다.

git branch 브랜치이름 :
	브랜치를 추가한다.
	마스터와 똑같은 상태를 복사한다.

git checkout 브랜치이름 :
	해당 브랜치로 이동한다. 파일의 내용도 해당 브랜치도 바햣 뀜.
git checkout 커밋 이름 : 
	해당 커밋으로 이동한다.
git checkout - :
	브랜치 최근 커밋으로 다시 이동한다.

branch  정보 확인 :
	git log --branches : 현재 체크아웃 된 브랜치 뿐만 아니라 모든 브랜치의 로그 확인한다.
	git log --branches --decorate : 어떤 브랜치인지 표시해준다.
	git log --branches --decorate --graph : 브랜치 커밋 현황 그림 그려준다.
	git log --branches --decorate --graph --oneline : 좀 더 간략하게.


	head -> 브랜치 이름 : head는 현재 체크아웃 된 브랜치. 가장 최신 커밋.

git log 브랜치1..브랜치2 : 브랜치1에는 없고 브랜치 2에는 있는 커밋을 알려준다.
	git log -p 브랜치1..브랜치2 : 소스코드 차이도 보여준다.

git diff 브랜치1..브랜치2 : 각 브랜치의 최신 커밋 코드의 차이를 보여준다.
	브랜치 1에는 없고 브랜치 2에는 있는 것.

git branch -d 브랜치 :
	브랜치 삭제


git merge 브랜치1 :
	현재 체크아웃 되어 있는 브랜치에, 브랜치1의 내용을 가져온다.
	즉, 현재 있는 곳에 해당 브랜치의 내용을 가져오는 것.
	이 때, 브랜치1이 현재 브랜치의 내용보다 추가만 된 상황이면 아무 문제 없이 머지 된다.
	하지만, 브랜치가 쪼개지고 난 후로부터 현재 브랜치(예를 들어 마스터)도 변경이 좀 있고 브랜치1도 변경사항이 있어서
	둘이 완전히 다른 커밋 히스토리를 몇 개 가지게 되었다면, 둘의 내용이 모두 표시되어 머지된다. 주의.

fast forward :
	마스터에서 쪼개져 나온 뒤 브랜치에서 수정을 하는 동안, 마스터가 아무런 변화를 주지 않은 경우,
	브랜치 수정 사항을 머지 하려고 마스터에 체크아웃 한다. 그 다음, 마스터에서 merge branch1을 하면, 별도의
	커밋이 생성되는 것이 아니라 마치 빨리감기 마냥 해당 커밋에서 바로 내용이 바뀐다. 빨리 감기(fast forwarding).

strategy :
	머지 하는 브랜치와 머지 대상 모두 변화가 있는 경우, 새로운 커밋을 만든다.

git stash save :
	커밋 하지 않고 다른 브랜치에 체크아웃 할 수 있도록, 변경 사항들을 숨긴다.

git stash list :
	스태시된 사항들의 리스트

git stash apply :
	저장된 마지막 사항을 복구시킨다. 스태시 리스트에서 삭제하지는 않는다.

git stash drop :
	스태시 리스트의 마지막을 지운다.

git stash pop : 
	저장된 스태시를 불러오고(apply) 동시에 드랍한다.


branch 원리 :
	HEAD : 헤드 보면 현재 위치(헤드)의 ref 파일이 있고, ref를 보면 헤드의 커밋이 있다.
	ref 파일은 각 브랜치마다 있고, 체크아웃을 할 때마다 HEAD가 가리키는 ref가 헤드의 ref로 바뀐다.
	ref은 해당 시점에서 그 브랜치의 최신 커밋을 가리킨다.


branch 충돌 해결 :
	다른 부분을 수정하였을 떄는 충돌이 일어나지 않는다.
	같은 부분을 수정하였을 때 충돌이 일어난다.

	both modified. 뜬다.

	이 때, 파일을 열어보면

	======= 을 기준으로,

	<<<<<<<<< 브랜치 1
	브랜치1 코드
	=============
	브랜치2 코드
	>>>>>>>>> 브랜치 2

	로 표기되는데, 이것을 사용자가 직접 수정하고, 표기는 전부 삭제한 다음,
	다시 add, commit하면 문제가 해결된다.


reset의 원리 :
	reset은 커밋을 삭제하는 것이 아니다. HEAD 가 참조하는 ref를 과거의 커밋 해시로 바꾸는 것.
	ref가 가리키는 커밋을 보면 과거의 커밋인 것을 알 수 있다.

	git은 reset으로 우리가 무엇을 삭제했는지도 모두 기록해 놓는다.
	위험한 작업(reset)을 하기 직전 최신 커밋은 ORIG_HEAD에 저장된다.
	따라서, reset을 취소하려면 git reset --hard ORIG_HEAD  명령을 하면 된다.

	ORIG_HEAD보다 더 좋은 것은  logs를 보는 것. 훨씬 더 자세히 나온다. gistory가 아니라 깃 배쉬에서
	logs 확인 하려면
	git reflog 입력.


과거 히스토리로 돌아가기(삭제가 아니라 헤드 옮기는 것) :
	git checkout 커밋id :
	해당 커밋 id로 헤드를 옮긴다. 그러면 HEAD가 ref를 가리키지 않고 해당 커밋id를 직접 가리키게 된다.
	detached 라고 표현함.

reset의 적용 범위 :

		working directory     index(staging area) : add된 장소    (local) repository/history/tree : 커밋 된 장소

	soft		x 								x  										o
	mixed		x 								o  										o
	hard 		o 								o  										o


	ex. soft : 커밋된 것만 바꾸고 staging area, working directory에 있는것은 그대로 놔둔다.
		mixed : add시켰던 것(staging area), 리파지터리에 있는 것 전부 과거로 돌리고 워킹 디렉토리(내가 하고 있는 작업)은 놔둔다.
